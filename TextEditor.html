class TextScratchExtension {
  constructor(runtime) {
    this.runtime = runtime;

    // Load saved code from localStorage
    this.code = localStorage.getItem("TextScratch_code") || 
`when key space pressed {
  repeat (10) times {
    move (10) steps
  }
}`;
    this.parsed = JSON.parse(localStorage.getItem("TextScratch_parsed") || "[]");

    this.editorWindow = null;

    // Bind message listener
    this._onMessage = this._onMessage.bind(this);
    window.addEventListener("message", this._onMessage);
  }

  getInfo() {
    return {
      id: "textscratch",
      name: "Text Scratch",
      blocks: [
        {
          opcode: "openEditor",
          blockType: Scratch.BlockType.COMMAND,
          text: "Open Text Scratch Editor"
        },
        {
          opcode: "runSaved",
          blockType: Scratch.BlockType.COMMAND,
          text: "Run saved Text Scratch code"
        }
      ]
    };
  }

  openEditor() {
    // If popup already open, just focus
    if (this.editorWindow && !this.editorWindow.closed) {
      this.editorWindow.focus();
      // Only send saved code once
      this.editorWindow.postMessage({ type: "PM_TEXT_CODE_LOAD", code: this.code }, "*");
      return;
    }

    // Open new popup
    this.editorWindow = window.open(
      "https://floppydisk-osc.github.io/extensions-assets/TextEditor.html",
      "TextScratchEditor",
      "width=1000,height=700"
    );

    // Send code once after popup is ready
    const sendCodeOnce = () => {
      if (!this.editorWindow || this.editorWindow.closed) return;
      this.editorWindow.postMessage({ type: "PM_TEXT_CODE_LOAD", code: this.code }, "*");
    };
    setTimeout(sendCodeOnce, 500);
  }

  _onMessage(e) {
    const data = e.data;
    if (!data?.source || data.source !== "TextEditor") return;

    // Save code & parsed blocks
    this.code = data.code || "";
    this.parsed = data.parsed || [];

    localStorage.setItem("TextScratch_code", this.code);
    localStorage.setItem("TextScratch_parsed", JSON.stringify(this.parsed));

    if (data.type === "PM_TEXT_CODE_SAVE") {
      console.log("[TextScratch] Code saved!");
    }
    if (data.type === "PM_TEXT_CODE_EXECUTE") {
      this.executeCode(this.parsed);
    }
  }

  runSaved() {
    if (!this.parsed.length) return alert("No code saved yet!");
    this.executeCode(this.parsed);
  }

  // ================= Execute parsed Scratch-text code =================
  executeCode(blocks, target) {
    // Safe execution: if target sprite is undefined, just log
    if (!target) {
      console.warn("[TextScratch] No target sprite available. Execution is in log-only mode.");
    }

    for (const block of blocks) {
      const line = block.line.toLowerCase();

      // Move steps (safe, won't crash without target)
      if (/move\s*\((\d+)\)\s*steps/.test(line)) {
        const match = line.match(/move\s*\((\d+)\)\s*steps/);
        const steps = parseInt(match[1], 10);
        if (target) {
          const rad = (target.direction || 0) * Math.PI / 180;
          target.setXY(target.x + steps * Math.cos(rad), target.y + steps * Math.sin(rad));
        }
        console.log(`[TextScratch] Move ${steps} steps`, target ? target : "(no sprite)");
      }

      // Repeat blocks
      else if (/repeat\s*\((\d+)\)\s*times/.test(line)) {
        const match = line.match(/repeat\s*\((\d+)\)\s*times/);
        const times = parseInt(match[1], 10);
        for (let i = 0; i < times; i++) {
          if (block.children) this.executeCode(block.children, target);
        }
      }

      // Execute children blocks recursively
      if (block.children) this.executeCode(block.children, target);
    }
  }
}

// Register the extension
Scratch.extensions.register(new TextScratchExtension());
