<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Text Scratch Editor</title>
<style>
html, body {
  margin: 0; padding: 0; height: 100%; width: 100%;
  font-family: monospace; background: #1e1e1e; color: white;
  display: flex; flex-direction: column;
}
#topbar {
  height: 40px; background: #252526;
  display: flex; align-items: center; padding: 0 10px; gap: 10px;
}
button {
  background: #0e639c; border: none; color: white;
  padding: 5px 12px; border-radius: 4px; cursor: pointer;
}
button:hover { background: #1177bb; }
#container {
  flex: 1; display: flex; overflow: hidden;
}
#editor {
  flex: 1; min-width: 0; height: 100%; background: #1e1e1e;
  padding: 10px; outline: none; overflow: auto;
  white-space: pre; caret-color: white; color: white;
}
#preview {
  flex: 0.4; background: #1b1b1b; border-left: 1px solid #333;
  overflow-y: auto; padding: 10px; min-width: 0;
}
.block { border-left: 4px solid #4FC3F7; padding: 2px 4px; margin: 2px 0; cursor: pointer; }
.motion { border-left-color: #4FC3F7; }
.control { border-left-color: #FFB74D; }
.event { border-left-color: #AED581; }
.nested { margin-left: 20px; }
.autocomplete {
  position: absolute; background: #333; color: white; border: 1px solid #555;
  font-family: monospace; z-index: 1000; padding: 2px;
}
.autocomplete div { padding: 2px 6px; cursor: pointer; }
.autocomplete div:hover { background: #555; }
</style>
</head>
<body>

<div id="topbar">
  <strong>ðŸ§  Text Scratch</strong>
  <button id="saveBtn">ðŸ’¾ Save</button>
  <button id="runBtn">â–¶ Run</button>
</div>

<div id="container">
  <div id="editor" contenteditable="true"></div>
  <div id="preview"></div>
</div>

<div id="autocomplete" class="autocomplete" style="display:none;"></div>

<script>
const editor = document.getElementById("editor");
const preview = document.getElementById("preview");
const ac = document.getElementById("autocomplete");

// Full Scratch command list
const commands = [
  "move (10) steps",
  "turn right (15) degrees",
  "turn left (15) degrees",
  "repeat (10) times {",
  "forever {",
  "if <key space pressed?> {",
  "else {",
  "when key space pressed"
];

// Load saved code
editor.textContent = localStorage.getItem("TextScratch_code") || `when key space pressed {
  repeat (10) times {
    move (10) steps
  }
}`;

// =================== Helpers ===================
function classify(line) {
  if (/move|turn/.test(line)) return "motion";
  if (/repeat|forever|if|else/.test(line)) return "control";
  if (/when key/.test(line)) return "event";
  return "other";
}

function parseScratchText(code) {
  const lines = code.split("\n").map(l => l.trim()).filter(Boolean);
  const stack = [{ children: [] }];
  lines.forEach(line => {
    if (line.endsWith("{")) {
      const block = { line, children: [], type: classify(line) };
      stack[stack.length-1].children.push(block);
      stack.push(block);
    } else if (line === "}") {
      stack.pop();
    } else {
      stack[stack.length-1].children.push({ line, type: classify(line) });
    }
  });
  return stack[0].children;
}

function renderPreview(blocks, container) {
  container.innerHTML = "";
  blocks.forEach(b => {
    const div = document.createElement("div");
    div.className = "block " + (b.type || "");
    div.textContent = b.line;
    container.appendChild(div);
    if (b.children) {
      const childDiv = document.createElement("div");
      childDiv.className = "nested";
      div.appendChild(childDiv);
      renderPreview(b.children, childDiv);
    }
  });
}

function updatePreview() {
  const code = editor.textContent;
  const parsed = parseScratchText(code);
  renderPreview(parsed, preview);
  return parsed;
}

// =================== Autocomplete ===================
function showAutocomplete(prefix) {
  const rect = editor.getBoundingClientRect();
  const matches = commands.filter(c => c.startsWith(prefix));
  if (!matches.length) { ac.style.display="none"; return; }
  ac.innerHTML = "";
  matches.forEach(m => {
    const div = document.createElement("div");
    div.textContent = m;
    div.onclick = () => {
      insertAutocomplete(m);
      ac.style.display="none";
      editor.focus();
    };
    ac.appendChild(div);
  });
  ac.style.display = "block";
  ac.style.left = rect.left + "px";
  ac.style.top = rect.top + 20 + "px";
}

function insertAutocomplete(text) {
  const sel = window.getSelection();
  if (!sel.rangeCount) return;
  const range = sel.getRangeAt(0);
  range.deleteContents();
  range.insertNode(document.createTextNode(text));
  sel.collapseToEnd();
}

// =================== Event Handlers ===================
editor.addEventListener("input", () => {
  updatePreview();
  localStorage.setItem("TextScratch_code", editor.textContent);
});

editor.addEventListener("keyup", (e) => {
  if (e.key.length === 1) {
    const words = editor.textContent.split(/\s/);
    const last = words[words.length-1];
    if(last) showAutocomplete(last);
    else ac.style.display="none";
  } else if(e.key === "Escape") {
    ac.style.display="none";
  }
});

updatePreview();

function sendMessage(type) {
  const code = editor.textContent;
  const parsed = updatePreview();
  window.opener?.postMessage({ type, source: "TextEditor", code, parsed }, "*");
  if(type === "PM_TEXT_CODE_SAVE") alert("ðŸ’¾ Code saved!");
}

document.getElementById("saveBtn").onclick = () => sendMessage("PM_TEXT_CODE_SAVE");
document.getElementById("runBtn").onclick = () => sendMessage("PM_TEXT_CODE_EXECUTE");

// Receive code from PM extension
window.addEventListener("message", e => {
  if(e.data?.type === "PM_TEXT_CODE_LOAD" && e.data.code){
    editor.textContent = e.data.code;
    updatePreview();
  }
});
</script>

</body>
</html>
