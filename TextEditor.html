<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Text Scratch Editor</title>
<style>
html, body {
  margin: 0; padding: 0; height: 100%; width: 100%;
  font-family: monospace; background: #1e1e1e; color: white;
  display: flex; flex-direction: column;
}
#topbar {
  height: 40px; background: #252526;
  display: flex; align-items: center; padding: 0 10px; gap: 10px;
}
button {
  background: #0e639c; border: none; color: white;
  padding: 5px 12px; border-radius: 4px; cursor: pointer;
}
button:hover { background: #1177bb; }
#container {
  flex: 1; display: flex; overflow: hidden;
}
#editor {
  flex: 1; min-width: 0; height: 100%; background: #1e1e1e;
  padding: 10px; outline: none; overflow: auto;
  white-space: pre; caret-color: white; color: white;
}
#preview {
  flex: 0.4; background: #1b1b1b; border-left: 1px solid #333;
  overflow-y: auto; padding: 10px; min-width: 0;
}
.block { border-left: 4px solid #4FC3F7; padding: 2px 4px; margin: 2px 0; cursor: pointer; }
.motion { border-left-color: #4FC3F7; }
.control { border-left-color: #FFB74D; }
.event { border-left-color: #AED581; }
.nested { margin-left: 20px; }
.autocomplete {
  position: absolute; background: #333; color: white; border: 1px solid #555;
  font-family: monospace; z-index: 1000; padding: 2px; display: none;
}
.autocomplete div { padding: 2px 6px; cursor: pointer; }
.autocomplete div:hover { background: #555; }
</style>
</head>
<body>

<div id="topbar">
  <strong>ðŸ§  Text Scratch</strong>
  <button id="saveBtn">ðŸ’¾ Save</button>
  <button id="runBtn">â–¶ Run</button>
</div>

<div id="container">
  <div id="editor" contenteditable="true"></div>
  <div id="preview"></div>
</div>

<div id="autocomplete" class="autocomplete"></div>

<script>
const editor = document.getElementById("editor");
const preview = document.getElementById("preview");
const ac = document.getElementById("autocomplete");

// Scratch-text commands for autocomplete
const commands = [
  "move (10) steps",
  "turn right (15) degrees",
  "turn left (15) degrees",
  "repeat (10) times {",
  "forever {",
  "if <key space pressed?> {",
  "else {",
  "when key space pressed"
];

// Load saved code
editor.textContent = localStorage.getItem("TextScratch_code") || 
`when key space pressed {
  repeat (10) times {
    move (10) steps
  }
}`;

// =============== Parsing and preview =================
function classify(line){
  if (/move|turn/.test(line)) return "motion";
  if (/repeat|forever|if|else/.test(line)) return "control";
  if (/when key/.test(line)) return "event";
  return "other";
}

function parseScratchText(code){
  const lines = code.split("\n").map(l=>l.trim()).filter(Boolean);
  const stack = [{ children: [] }];
  let current = stack[0];
  let lastIfBlock = null;

  lines.forEach(line=>{
    if(line.endsWith("{") && !line.startsWith("else")){
      const block = { line, children: [], type: classify(line) };
      current.children.push(block);
      stack.push(block);
      current = block;
      if (/if /.test(line)) lastIfBlock = block;
    } else if(line === "else {"){
      if(lastIfBlock){
        const block = { children: [], type: "control" };
        lastIfBlock.elseChildren = block.children;
        stack.push(block);
        current = block;
      }
    } else if(line === "}"){
      stack.pop();
      current = stack[stack.length-1];
    } else {
      current.children.push({ line, type: classify(line) });
    }
  });
  return stack[0].children;
}

function renderPreview(blocks, container){
  container.innerHTML = "";
  blocks.forEach(b=>{
    const div = document.createElement("div");
    div.className = "block " + (b.type || "");
    div.textContent = b.line;
    container.appendChild(div);
    if(b.children){
      const childDiv = document.createElement("div");
      childDiv.className = "nested";
      div.appendChild(childDiv);
      renderPreview(b.children, childDiv);
    }
  });
}

function updatePreview(){
  const parsed = parseScratchText(editor.textContent);
  renderPreview(parsed, preview);
  return parsed;
}

// =============== Autocomplete =================
function getCurrentWord(){
  const sel = window.getSelection();
  if(!sel.rangeCount) return "";
  const range = sel.getRangeAt(0).cloneRange();
  range.collapse(true);
  range.setStart(editor,0);
  const text = range.toString();
  const match = text.match(/(\S+)$/);
  return match ? match[1] : "";
}

function showAutocomplete(prefix){
  const matches = commands.filter(c=>c.startsWith(prefix));
  if(!matches.length){ ac.style.display="none"; return; }
  ac.innerHTML = "";
  matches.forEach(m=>{
    const div = document.createElement("div");
    div.textContent = m;
    div.onclick = ()=>{ insertAutocomplete(m); ac.style.display="none"; };
    ac.appendChild(div);
  });
  const sel = window.getSelection();
  if(!sel.rangeCount) return;
  const rect = sel.getRangeAt(0).getBoundingClientRect();
  ac.style.left = rect.left + "px";
  ac.style.top = rect.bottom + "px";
  ac.style.display="block";
}

function insertAutocomplete(text){
  const sel = window.getSelection();
  if(!sel.rangeCount) return;
  const range = sel.getRangeAt(0);

  // Delete last word
  const startOffset = range.startOffset;
  let node = range.startContainer;
  if(node.nodeType===3){
    const value = node.nodeValue;
    const lastWordMatch = value.slice(0,startOffset).match(/(\S+)$/);
    if(lastWordMatch){
      const lastWordLength = lastWordMatch[1].length;
      node.nodeValue = value.slice(0,startOffset-lastWordLength) + value.slice(startOffset);
      range.setStart(node,startOffset-lastWordLength);
      range.setEnd(node,startOffset-lastWordLength);
    }
  }

  // Insert new text
  const textNode = document.createTextNode(text + " ");
  range.insertNode(textNode);
  range.setStartAfter(textNode);
  range.collapse(true);
  sel.removeAllRanges();
  sel.addRange(range);
  editor.focus();
}

// =============== Events =================
editor.addEventListener("input", ()=>{
  updatePreview();
  localStorage.setItem("TextScratch_code", editor.textContent);
});

editor.addEventListener("keyup", e=>{
  if(e.key.length===1||e.key==="Backspace"){
    const word = getCurrentWord();
    if(word) showAutocomplete(word);
    else ac.style.display="none";
  } else if(e.key==="Escape") ac.style.display="none";
});

updatePreview();

function sendMessage(type){
  const parsed = updatePreview();
  window.opener?.postMessage({ type, source:"TextEditor", code: editor.textContent, parsed }, "*");
  if(type==="PM_TEXT_CODE_SAVE") alert("ðŸ’¾ Code saved!");
}

document.getElementById("saveBtn").onclick = ()=>sendMessage("PM_TEXT_CODE_SAVE");
document.getElementById("runBtn").onclick = ()=>sendMessage("PM_TEXT_CODE_EXECUTE");

window.addEventListener("message", e=>{
  if(e.data?.type==="PM_TEXT_CODE_LOAD" && e.data.code){
    editor.textContent = e.data.code;
    updatePreview();
  }
});
</script>

</body>
</html>
